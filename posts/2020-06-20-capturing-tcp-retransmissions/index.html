<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Network: Capturing TCP Retransmissions | My Digital Chronicle</title>
<meta name="keywords" content="linux, network, tcp">
<meta name="description" content="When server have a lot network connections it&rsquo;s not rare to see tcp retransmissions. The permanent background retransmissions it&rsquo;s even normal situation if it&rsquo;s not abnormally high.
But when the charts shows abnormally jump of retransmissions it&rsquo;s good to find the reason.
The reason is may be:
server is overloaded remote server is overloaded network where servers is based is degraded network of remote endpoint is degraded When servers is not overloaded the next step is to find which endpoint causes the retransmissions.">
<meta name="author" content="">
<link rel="canonical" href="http://undying.github.io/posts/2020-06-20-capturing-tcp-retransmissions/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://undying.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://undying.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://undying.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://undying.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="http://undying.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5GK4JRS');</script>

<meta property="og:title" content="Network: Capturing TCP Retransmissions" />
<meta property="og:description" content="When server have a lot network connections it&rsquo;s not rare to see tcp retransmissions. The permanent background retransmissions it&rsquo;s even normal situation if it&rsquo;s not abnormally high.
But when the charts shows abnormally jump of retransmissions it&rsquo;s good to find the reason.
The reason is may be:
server is overloaded remote server is overloaded network where servers is based is degraded network of remote endpoint is degraded When servers is not overloaded the next step is to find which endpoint causes the retransmissions." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://undying.github.io/posts/2020-06-20-capturing-tcp-retransmissions/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-20T16:04:35+03:00" />
<meta property="article:modified_time" content="2020-06-20T16:04:35+03:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Network: Capturing TCP Retransmissions"/>
<meta name="twitter:description" content="When server have a lot network connections it&rsquo;s not rare to see tcp retransmissions. The permanent background retransmissions it&rsquo;s even normal situation if it&rsquo;s not abnormally high.
But when the charts shows abnormally jump of retransmissions it&rsquo;s good to find the reason.
The reason is may be:
server is overloaded remote server is overloaded network where servers is based is degraded network of remote endpoint is degraded When servers is not overloaded the next step is to find which endpoint causes the retransmissions."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "http://undying.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Network: Capturing TCP Retransmissions",
      "item": "http://undying.github.io/posts/2020-06-20-capturing-tcp-retransmissions/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Network: Capturing TCP Retransmissions",
  "name": "Network: Capturing TCP Retransmissions",
  "description": "When server have a lot network connections it\u0026rsquo;s not rare to see tcp retransmissions. The permanent background retransmissions it\u0026rsquo;s even normal situation if it\u0026rsquo;s not abnormally high.\nBut when the charts shows abnormally jump of retransmissions it\u0026rsquo;s good to find the reason.\nThe reason is may be:\nserver is overloaded remote server is overloaded network where servers is based is degraded network of remote endpoint is degraded When servers is not overloaded the next step is to find which endpoint causes the retransmissions.",
  "keywords": [
    "linux", "network", "tcp"
  ],
  "articleBody": "When server have a lot network connections it’s not rare to see tcp retransmissions. The permanent background retransmissions it’s even normal situation if it’s not abnormally high.\nBut when the charts shows abnormally jump of retransmissions it’s good to find the reason.\nThe reason is may be:\nserver is overloaded remote server is overloaded network where servers is based is degraded network of remote endpoint is degraded When servers is not overloaded the next step is to find which endpoint causes the retransmissions. We can see this in multiple ways described below.\nNetstat To begin with it makes sense to collect statistics on retransmited packages. Netstat can help with that. Compare total segments count with retransmited. netstat -s|grep segments TShark Realtime output with source and destination tshark -R tcp.analysis.retransmission Capture result into pcap file tshark -i any -w /tmp/result.pcap -R tcp.analysis.retransmission Collecting data and displaying statistics after the CTRL-C tshark -q -z io,stat,1,\"COUNT(tcp.analysis.retransmission) tcp.analysis.retransmission\" Use more columns in statistics. tshark -q -z io,stat,1,\\ \"COUNT(tcp.analysis.fast_retransmission) tcp.analysis.fast_retransmission\",\\ \"COUNT(tcp.analysis.retransmission) tcp.analysis.retransmission\",\\ \"COUNT(tcp.analysis.duplicate_ack) tcp.analysis.duplicate_ack\",\\ \"COUNT(tcp.analysis.lost_segment) tcp.analysis.lost_segment\" Perf-Tools perf-tools has great tool named tcpretrans. ./tcpretrans TIME PID LADDR:LPORT -- RADDR:RPORT STATE 05:16:44 3375 10.150.18.225:53874 R\u003e 10.105.152.3:6001 ESTABLISHED 05:16:44 3375 10.150.18.225:53874 R\u003e 10.105.152.3:6001 ESTABLISHED 05:16:54 4028 10.150.18.225:6002 R\u003e 10.150.30.249:1710 ESTABLISHED ",
  "wordCount" : "203",
  "inLanguage": "en",
  "datePublished": "2020-06-20T16:04:35+03:00",
  "dateModified": "2020-06-20T16:04:35+03:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://undying.github.io/posts/2020-06-20-capturing-tcp-retransmissions/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "My Digital Chronicle",
    "logo": {
      "@type": "ImageObject",
      "url": "http://undying.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://undying.github.io" accesskey="h" title="My Digital Chronicle (Alt + H)">My Digital Chronicle</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://undying.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Network: Capturing TCP Retransmissions
    </h1>
    <div class="post-meta"><span title='2020-06-20 16:04:35 +0300 MSK'>June 20, 2020</span>

</div>
  </header> 
  <div class="post-content"><p>When server have a lot network connections it&rsquo;s not rare to see tcp retransmissions. The permanent background retransmissions it&rsquo;s even normal situation if it&rsquo;s not abnormally high.</p>
<p>But when the charts shows abnormally jump of retransmissions it&rsquo;s good to find the reason.</p>
<p>The reason is may be:</p>
<ul>
<li>server is overloaded</li>
<li>remote server is overloaded</li>
<li>network where servers is based is degraded</li>
<li>network of remote endpoint is degraded</li>
</ul>
<p>When servers is not overloaded the next step is to find which endpoint causes the retransmissions. We can see this in multiple ways described below.</p>
<h3 id="netstathttpslinuxdienetman8netstat"><a href="https://linux.die.net/man/8/netstat">Netstat</a><a hidden class="anchor" aria-hidden="true" href="#netstathttpslinuxdienetman8netstat">#</a></h3>
<ul>
<li>To begin with it makes sense to collect statistics on retransmited packages. Netstat can help with that.
Compare total segments count with retransmited.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>netstat -s|grep segments
</span></span></code></pre></div><h3 id="tsharkhttpswwwwiresharkorgdocsman-pagestsharkhtml"><a href="https://www.wireshark.org/docs/man-pages/tshark.html">TShark</a><a hidden class="anchor" aria-hidden="true" href="#tsharkhttpswwwwiresharkorgdocsman-pagestsharkhtml">#</a></h3>
<ul>
<li>Realtime output with source and destination</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>tshark -R tcp.analysis.retransmission
</span></span></code></pre></div><ul>
<li>Capture result into pcap file</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>tshark -i any -w /tmp/result.pcap -R tcp.analysis.retransmission
</span></span></code></pre></div><ul>
<li>Collecting data and displaying statistics after the CTRL-C</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>tshark -q -z io,stat,1,<span style="color:#e6db74">&#34;COUNT(tcp.analysis.retransmission) tcp.analysis.retransmission&#34;</span>
</span></span></code></pre></div><ul>
<li>Use more columns in statistics.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>tshark -q -z io,stat,1,<span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">&#34;COUNT(tcp.analysis.fast_retransmission) tcp.analysis.fast_retransmission&#34;</span>,<span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">&#34;COUNT(tcp.analysis.retransmission) tcp.analysis.retransmission&#34;</span>,<span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">&#34;COUNT(tcp.analysis.duplicate_ack) tcp.analysis.duplicate_ack&#34;</span>,<span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">&#34;COUNT(tcp.analysis.lost_segment) tcp.analysis.lost_segment&#34;</span>
</span></span></code></pre></div><h3 id="perf-toolshttpsgithubcombrendangreggperf-tools"><a href="https://github.com/brendangregg/perf-tools">Perf-Tools</a><a hidden class="anchor" aria-hidden="true" href="#perf-toolshttpsgithubcombrendangreggperf-tools">#</a></h3>
<ul>
<li>perf-tools has great tool named <a href="https://github.com/brendangregg/perf-tools/blob/master/net/tcpretrans">tcpretrans</a>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>./tcpretrans
</span></span><span style="display:flex;"><span>TIME     PID    LADDR:LPORT          -- RADDR:RPORT          STATE
</span></span><span style="display:flex;"><span>05:16:44 <span style="color:#ae81ff">3375</span>   10.150.18.225:53874  R&gt; 10.105.152.3:6001    ESTABLISHED
</span></span><span style="display:flex;"><span>05:16:44 <span style="color:#ae81ff">3375</span>   10.150.18.225:53874  R&gt; 10.105.152.3:6001    ESTABLISHED
</span></span><span style="display:flex;"><span>05:16:54 <span style="color:#ae81ff">4028</span>   10.150.18.225:6002   R&gt; 10.150.30.249:1710   ESTABLISHED
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://undying.github.io/tags/linux/">linux</a></li>
      <li><a href="http://undying.github.io/tags/network/">network</a></li>
      <li><a href="http://undying.github.io/tags/tcp/">tcp</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="http://undying.github.io">My Digital Chronicle</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
